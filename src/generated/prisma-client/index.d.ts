// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  budget: (where?: BudgetWhereInput) => Promise<boolean>;
  expense: (where?: ExpenseWhereInput) => Promise<boolean>;
  savings: (where?: SavingsWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  budget: (where: BudgetWhereUniqueInput) => BudgetNullablePromise;
  budgets: (args?: {
    where?: BudgetWhereInput;
    orderBy?: BudgetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Budget>;
  budgetsConnection: (args?: {
    where?: BudgetWhereInput;
    orderBy?: BudgetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BudgetConnectionPromise;
  expense: (where: ExpenseWhereUniqueInput) => ExpenseNullablePromise;
  expenses: (args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Expense>;
  expensesConnection: (args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ExpenseConnectionPromise;
  savings: (where: SavingsWhereUniqueInput) => SavingsNullablePromise;
  savingses: (args?: {
    where?: SavingsWhereInput;
    orderBy?: SavingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Savings>;
  savingsesConnection: (args?: {
    where?: SavingsWhereInput;
    orderBy?: SavingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SavingsConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBudget: (data: BudgetCreateInput) => BudgetPromise;
  updateBudget: (args: {
    data: BudgetUpdateInput;
    where: BudgetWhereUniqueInput;
  }) => BudgetPromise;
  updateManyBudgets: (args: {
    data: BudgetUpdateManyMutationInput;
    where?: BudgetWhereInput;
  }) => BatchPayloadPromise;
  upsertBudget: (args: {
    where: BudgetWhereUniqueInput;
    create: BudgetCreateInput;
    update: BudgetUpdateInput;
  }) => BudgetPromise;
  deleteBudget: (where: BudgetWhereUniqueInput) => BudgetPromise;
  deleteManyBudgets: (where?: BudgetWhereInput) => BatchPayloadPromise;
  createExpense: (data: ExpenseCreateInput) => ExpensePromise;
  updateExpense: (args: {
    data: ExpenseUpdateInput;
    where: ExpenseWhereUniqueInput;
  }) => ExpensePromise;
  updateManyExpenses: (args: {
    data: ExpenseUpdateManyMutationInput;
    where?: ExpenseWhereInput;
  }) => BatchPayloadPromise;
  upsertExpense: (args: {
    where: ExpenseWhereUniqueInput;
    create: ExpenseCreateInput;
    update: ExpenseUpdateInput;
  }) => ExpensePromise;
  deleteExpense: (where: ExpenseWhereUniqueInput) => ExpensePromise;
  deleteManyExpenses: (where?: ExpenseWhereInput) => BatchPayloadPromise;
  createSavings: (data: SavingsCreateInput) => SavingsPromise;
  updateSavings: (args: {
    data: SavingsUpdateInput;
    where: SavingsWhereUniqueInput;
  }) => SavingsPromise;
  updateManySavingses: (args: {
    data: SavingsUpdateManyMutationInput;
    where?: SavingsWhereInput;
  }) => BatchPayloadPromise;
  upsertSavings: (args: {
    where: SavingsWhereUniqueInput;
    create: SavingsCreateInput;
    update: SavingsUpdateInput;
  }) => SavingsPromise;
  deleteSavings: (where: SavingsWhereUniqueInput) => SavingsPromise;
  deleteManySavingses: (where?: SavingsWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  budget: (
    where?: BudgetSubscriptionWhereInput
  ) => BudgetSubscriptionPayloadSubscription;
  expense: (
    where?: ExpenseSubscriptionWhereInput
  ) => ExpenseSubscriptionPayloadSubscription;
  savings: (
    where?: SavingsSubscriptionWhereInput
  ) => SavingsSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ExpenseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "expenseAmount_ASC"
  | "expenseAmount_DESC"
  | "expenseDesc_ASC"
  | "expenseDesc_DESC"
  | "expenseCategory_ASC"
  | "expenseCategory_DESC";

export type SavingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "total_ASC"
  | "total_DESC"
  | "month_ASC"
  | "month_DESC"
  | "monthAmount_ASC"
  | "monthAmount_DESC";

export type BudgetOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "total_ASC"
  | "total_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "savingsTarget_ASC"
  | "savingsTarget_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type BudgetWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
}>;

export interface ExpenseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  expenseAmount?: Maybe<Float>;
  expenseAmount_not?: Maybe<Float>;
  expenseAmount_in?: Maybe<Float[] | Float>;
  expenseAmount_not_in?: Maybe<Float[] | Float>;
  expenseAmount_lt?: Maybe<Float>;
  expenseAmount_lte?: Maybe<Float>;
  expenseAmount_gt?: Maybe<Float>;
  expenseAmount_gte?: Maybe<Float>;
  expenseDesc?: Maybe<String>;
  expenseDesc_not?: Maybe<String>;
  expenseDesc_in?: Maybe<String[] | String>;
  expenseDesc_not_in?: Maybe<String[] | String>;
  expenseDesc_lt?: Maybe<String>;
  expenseDesc_lte?: Maybe<String>;
  expenseDesc_gt?: Maybe<String>;
  expenseDesc_gte?: Maybe<String>;
  expenseDesc_contains?: Maybe<String>;
  expenseDesc_not_contains?: Maybe<String>;
  expenseDesc_starts_with?: Maybe<String>;
  expenseDesc_not_starts_with?: Maybe<String>;
  expenseDesc_ends_with?: Maybe<String>;
  expenseDesc_not_ends_with?: Maybe<String>;
  expenseCategory?: Maybe<String>;
  expenseCategory_not?: Maybe<String>;
  expenseCategory_in?: Maybe<String[] | String>;
  expenseCategory_not_in?: Maybe<String[] | String>;
  expenseCategory_lt?: Maybe<String>;
  expenseCategory_lte?: Maybe<String>;
  expenseCategory_gt?: Maybe<String>;
  expenseCategory_gte?: Maybe<String>;
  expenseCategory_contains?: Maybe<String>;
  expenseCategory_not_contains?: Maybe<String>;
  expenseCategory_starts_with?: Maybe<String>;
  expenseCategory_not_starts_with?: Maybe<String>;
  expenseCategory_ends_with?: Maybe<String>;
  expenseCategory_not_ends_with?: Maybe<String>;
  AND?: Maybe<ExpenseWhereInput[] | ExpenseWhereInput>;
  OR?: Maybe<ExpenseWhereInput[] | ExpenseWhereInput>;
  NOT?: Maybe<ExpenseWhereInput[] | ExpenseWhereInput>;
}

export interface SavingsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  total?: Maybe<Float>;
  total_not?: Maybe<Float>;
  total_in?: Maybe<Float[] | Float>;
  total_not_in?: Maybe<Float[] | Float>;
  total_lt?: Maybe<Float>;
  total_lte?: Maybe<Float>;
  total_gt?: Maybe<Float>;
  total_gte?: Maybe<Float>;
  month?: Maybe<String>;
  month_not?: Maybe<String>;
  month_in?: Maybe<String[] | String>;
  month_not_in?: Maybe<String[] | String>;
  month_lt?: Maybe<String>;
  month_lte?: Maybe<String>;
  month_gt?: Maybe<String>;
  month_gte?: Maybe<String>;
  month_contains?: Maybe<String>;
  month_not_contains?: Maybe<String>;
  month_starts_with?: Maybe<String>;
  month_not_starts_with?: Maybe<String>;
  month_ends_with?: Maybe<String>;
  month_not_ends_with?: Maybe<String>;
  monthAmount?: Maybe<Float>;
  monthAmount_not?: Maybe<Float>;
  monthAmount_in?: Maybe<Float[] | Float>;
  monthAmount_not_in?: Maybe<Float[] | Float>;
  monthAmount_lt?: Maybe<Float>;
  monthAmount_lte?: Maybe<Float>;
  monthAmount_gt?: Maybe<Float>;
  monthAmount_gte?: Maybe<Float>;
  AND?: Maybe<SavingsWhereInput[] | SavingsWhereInput>;
  OR?: Maybe<SavingsWhereInput[] | SavingsWhereInput>;
  NOT?: Maybe<SavingsWhereInput[] | SavingsWhereInput>;
}

export interface BudgetWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  total?: Maybe<Float>;
  total_not?: Maybe<Float>;
  total_in?: Maybe<Float[] | Float>;
  total_not_in?: Maybe<Float[] | Float>;
  total_lt?: Maybe<Float>;
  total_lte?: Maybe<Float>;
  total_gt?: Maybe<Float>;
  total_gte?: Maybe<Float>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  savingsTarget?: Maybe<Float>;
  savingsTarget_not?: Maybe<Float>;
  savingsTarget_in?: Maybe<Float[] | Float>;
  savingsTarget_not_in?: Maybe<Float[] | Float>;
  savingsTarget_lt?: Maybe<Float>;
  savingsTarget_lte?: Maybe<Float>;
  savingsTarget_gt?: Maybe<Float>;
  savingsTarget_gte?: Maybe<Float>;
  expenses_every?: Maybe<ExpenseWhereInput>;
  expenses_some?: Maybe<ExpenseWhereInput>;
  expenses_none?: Maybe<ExpenseWhereInput>;
  savings_every?: Maybe<SavingsWhereInput>;
  savings_some?: Maybe<SavingsWhereInput>;
  savings_none?: Maybe<SavingsWhereInput>;
  AND?: Maybe<BudgetWhereInput[] | BudgetWhereInput>;
  OR?: Maybe<BudgetWhereInput[] | BudgetWhereInput>;
  NOT?: Maybe<BudgetWhereInput[] | BudgetWhereInput>;
}

export type ExpenseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SavingsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  budgets_every?: Maybe<BudgetWhereInput>;
  budgets_some?: Maybe<BudgetWhereInput>;
  budgets_none?: Maybe<BudgetWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface BudgetCreateInput {
  id?: Maybe<ID_Input>;
  total: Float;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  savingsTarget: Float;
  expenses?: Maybe<ExpenseCreateManyInput>;
  savings?: Maybe<SavingsCreateManyInput>;
}

export interface ExpenseCreateManyInput {
  create?: Maybe<ExpenseCreateInput[] | ExpenseCreateInput>;
  connect?: Maybe<ExpenseWhereUniqueInput[] | ExpenseWhereUniqueInput>;
}

export interface ExpenseCreateInput {
  id?: Maybe<ID_Input>;
  expenseAmount: Float;
  expenseDesc: String;
  expenseCategory: String;
}

export interface SavingsCreateManyInput {
  create?: Maybe<SavingsCreateInput[] | SavingsCreateInput>;
  connect?: Maybe<SavingsWhereUniqueInput[] | SavingsWhereUniqueInput>;
}

export interface SavingsCreateInput {
  id?: Maybe<ID_Input>;
  total: Float;
  month: String;
  monthAmount: Float;
}

export interface BudgetUpdateInput {
  total?: Maybe<Float>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  savingsTarget?: Maybe<Float>;
  expenses?: Maybe<ExpenseUpdateManyInput>;
  savings?: Maybe<SavingsUpdateManyInput>;
}

export interface ExpenseUpdateManyInput {
  create?: Maybe<ExpenseCreateInput[] | ExpenseCreateInput>;
  update?: Maybe<
    | ExpenseUpdateWithWhereUniqueNestedInput[]
    | ExpenseUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ExpenseUpsertWithWhereUniqueNestedInput[]
    | ExpenseUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ExpenseWhereUniqueInput[] | ExpenseWhereUniqueInput>;
  connect?: Maybe<ExpenseWhereUniqueInput[] | ExpenseWhereUniqueInput>;
  set?: Maybe<ExpenseWhereUniqueInput[] | ExpenseWhereUniqueInput>;
  disconnect?: Maybe<ExpenseWhereUniqueInput[] | ExpenseWhereUniqueInput>;
  deleteMany?: Maybe<ExpenseScalarWhereInput[] | ExpenseScalarWhereInput>;
  updateMany?: Maybe<
    | ExpenseUpdateManyWithWhereNestedInput[]
    | ExpenseUpdateManyWithWhereNestedInput
  >;
}

export interface ExpenseUpdateWithWhereUniqueNestedInput {
  where: ExpenseWhereUniqueInput;
  data: ExpenseUpdateDataInput;
}

export interface ExpenseUpdateDataInput {
  expenseAmount?: Maybe<Float>;
  expenseDesc?: Maybe<String>;
  expenseCategory?: Maybe<String>;
}

export interface ExpenseUpsertWithWhereUniqueNestedInput {
  where: ExpenseWhereUniqueInput;
  update: ExpenseUpdateDataInput;
  create: ExpenseCreateInput;
}

export interface ExpenseScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  expenseAmount?: Maybe<Float>;
  expenseAmount_not?: Maybe<Float>;
  expenseAmount_in?: Maybe<Float[] | Float>;
  expenseAmount_not_in?: Maybe<Float[] | Float>;
  expenseAmount_lt?: Maybe<Float>;
  expenseAmount_lte?: Maybe<Float>;
  expenseAmount_gt?: Maybe<Float>;
  expenseAmount_gte?: Maybe<Float>;
  expenseDesc?: Maybe<String>;
  expenseDesc_not?: Maybe<String>;
  expenseDesc_in?: Maybe<String[] | String>;
  expenseDesc_not_in?: Maybe<String[] | String>;
  expenseDesc_lt?: Maybe<String>;
  expenseDesc_lte?: Maybe<String>;
  expenseDesc_gt?: Maybe<String>;
  expenseDesc_gte?: Maybe<String>;
  expenseDesc_contains?: Maybe<String>;
  expenseDesc_not_contains?: Maybe<String>;
  expenseDesc_starts_with?: Maybe<String>;
  expenseDesc_not_starts_with?: Maybe<String>;
  expenseDesc_ends_with?: Maybe<String>;
  expenseDesc_not_ends_with?: Maybe<String>;
  expenseCategory?: Maybe<String>;
  expenseCategory_not?: Maybe<String>;
  expenseCategory_in?: Maybe<String[] | String>;
  expenseCategory_not_in?: Maybe<String[] | String>;
  expenseCategory_lt?: Maybe<String>;
  expenseCategory_lte?: Maybe<String>;
  expenseCategory_gt?: Maybe<String>;
  expenseCategory_gte?: Maybe<String>;
  expenseCategory_contains?: Maybe<String>;
  expenseCategory_not_contains?: Maybe<String>;
  expenseCategory_starts_with?: Maybe<String>;
  expenseCategory_not_starts_with?: Maybe<String>;
  expenseCategory_ends_with?: Maybe<String>;
  expenseCategory_not_ends_with?: Maybe<String>;
  AND?: Maybe<ExpenseScalarWhereInput[] | ExpenseScalarWhereInput>;
  OR?: Maybe<ExpenseScalarWhereInput[] | ExpenseScalarWhereInput>;
  NOT?: Maybe<ExpenseScalarWhereInput[] | ExpenseScalarWhereInput>;
}

export interface ExpenseUpdateManyWithWhereNestedInput {
  where: ExpenseScalarWhereInput;
  data: ExpenseUpdateManyDataInput;
}

export interface ExpenseUpdateManyDataInput {
  expenseAmount?: Maybe<Float>;
  expenseDesc?: Maybe<String>;
  expenseCategory?: Maybe<String>;
}

export interface SavingsUpdateManyInput {
  create?: Maybe<SavingsCreateInput[] | SavingsCreateInput>;
  update?: Maybe<
    | SavingsUpdateWithWhereUniqueNestedInput[]
    | SavingsUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | SavingsUpsertWithWhereUniqueNestedInput[]
    | SavingsUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<SavingsWhereUniqueInput[] | SavingsWhereUniqueInput>;
  connect?: Maybe<SavingsWhereUniqueInput[] | SavingsWhereUniqueInput>;
  set?: Maybe<SavingsWhereUniqueInput[] | SavingsWhereUniqueInput>;
  disconnect?: Maybe<SavingsWhereUniqueInput[] | SavingsWhereUniqueInput>;
  deleteMany?: Maybe<SavingsScalarWhereInput[] | SavingsScalarWhereInput>;
  updateMany?: Maybe<
    | SavingsUpdateManyWithWhereNestedInput[]
    | SavingsUpdateManyWithWhereNestedInput
  >;
}

export interface SavingsUpdateWithWhereUniqueNestedInput {
  where: SavingsWhereUniqueInput;
  data: SavingsUpdateDataInput;
}

export interface SavingsUpdateDataInput {
  total?: Maybe<Float>;
  month?: Maybe<String>;
  monthAmount?: Maybe<Float>;
}

export interface SavingsUpsertWithWhereUniqueNestedInput {
  where: SavingsWhereUniqueInput;
  update: SavingsUpdateDataInput;
  create: SavingsCreateInput;
}

export interface SavingsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  total?: Maybe<Float>;
  total_not?: Maybe<Float>;
  total_in?: Maybe<Float[] | Float>;
  total_not_in?: Maybe<Float[] | Float>;
  total_lt?: Maybe<Float>;
  total_lte?: Maybe<Float>;
  total_gt?: Maybe<Float>;
  total_gte?: Maybe<Float>;
  month?: Maybe<String>;
  month_not?: Maybe<String>;
  month_in?: Maybe<String[] | String>;
  month_not_in?: Maybe<String[] | String>;
  month_lt?: Maybe<String>;
  month_lte?: Maybe<String>;
  month_gt?: Maybe<String>;
  month_gte?: Maybe<String>;
  month_contains?: Maybe<String>;
  month_not_contains?: Maybe<String>;
  month_starts_with?: Maybe<String>;
  month_not_starts_with?: Maybe<String>;
  month_ends_with?: Maybe<String>;
  month_not_ends_with?: Maybe<String>;
  monthAmount?: Maybe<Float>;
  monthAmount_not?: Maybe<Float>;
  monthAmount_in?: Maybe<Float[] | Float>;
  monthAmount_not_in?: Maybe<Float[] | Float>;
  monthAmount_lt?: Maybe<Float>;
  monthAmount_lte?: Maybe<Float>;
  monthAmount_gt?: Maybe<Float>;
  monthAmount_gte?: Maybe<Float>;
  AND?: Maybe<SavingsScalarWhereInput[] | SavingsScalarWhereInput>;
  OR?: Maybe<SavingsScalarWhereInput[] | SavingsScalarWhereInput>;
  NOT?: Maybe<SavingsScalarWhereInput[] | SavingsScalarWhereInput>;
}

export interface SavingsUpdateManyWithWhereNestedInput {
  where: SavingsScalarWhereInput;
  data: SavingsUpdateManyDataInput;
}

export interface SavingsUpdateManyDataInput {
  total?: Maybe<Float>;
  month?: Maybe<String>;
  monthAmount?: Maybe<Float>;
}

export interface BudgetUpdateManyMutationInput {
  total?: Maybe<Float>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  savingsTarget?: Maybe<Float>;
}

export interface ExpenseUpdateInput {
  expenseAmount?: Maybe<Float>;
  expenseDesc?: Maybe<String>;
  expenseCategory?: Maybe<String>;
}

export interface ExpenseUpdateManyMutationInput {
  expenseAmount?: Maybe<Float>;
  expenseDesc?: Maybe<String>;
  expenseCategory?: Maybe<String>;
}

export interface SavingsUpdateInput {
  total?: Maybe<Float>;
  month?: Maybe<String>;
  monthAmount?: Maybe<Float>;
}

export interface SavingsUpdateManyMutationInput {
  total?: Maybe<Float>;
  month?: Maybe<String>;
  monthAmount?: Maybe<Float>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  email: String;
  password: String;
  budgets?: Maybe<BudgetCreateManyInput>;
}

export interface BudgetCreateManyInput {
  create?: Maybe<BudgetCreateInput[] | BudgetCreateInput>;
  connect?: Maybe<BudgetWhereUniqueInput[] | BudgetWhereUniqueInput>;
}

export interface UserUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  budgets?: Maybe<BudgetUpdateManyInput>;
}

export interface BudgetUpdateManyInput {
  create?: Maybe<BudgetCreateInput[] | BudgetCreateInput>;
  update?: Maybe<
    | BudgetUpdateWithWhereUniqueNestedInput[]
    | BudgetUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | BudgetUpsertWithWhereUniqueNestedInput[]
    | BudgetUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<BudgetWhereUniqueInput[] | BudgetWhereUniqueInput>;
  connect?: Maybe<BudgetWhereUniqueInput[] | BudgetWhereUniqueInput>;
  set?: Maybe<BudgetWhereUniqueInput[] | BudgetWhereUniqueInput>;
  disconnect?: Maybe<BudgetWhereUniqueInput[] | BudgetWhereUniqueInput>;
  deleteMany?: Maybe<BudgetScalarWhereInput[] | BudgetScalarWhereInput>;
  updateMany?: Maybe<
    | BudgetUpdateManyWithWhereNestedInput[]
    | BudgetUpdateManyWithWhereNestedInput
  >;
}

export interface BudgetUpdateWithWhereUniqueNestedInput {
  where: BudgetWhereUniqueInput;
  data: BudgetUpdateDataInput;
}

export interface BudgetUpdateDataInput {
  total?: Maybe<Float>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  savingsTarget?: Maybe<Float>;
  expenses?: Maybe<ExpenseUpdateManyInput>;
  savings?: Maybe<SavingsUpdateManyInput>;
}

export interface BudgetUpsertWithWhereUniqueNestedInput {
  where: BudgetWhereUniqueInput;
  update: BudgetUpdateDataInput;
  create: BudgetCreateInput;
}

export interface BudgetScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  total?: Maybe<Float>;
  total_not?: Maybe<Float>;
  total_in?: Maybe<Float[] | Float>;
  total_not_in?: Maybe<Float[] | Float>;
  total_lt?: Maybe<Float>;
  total_lte?: Maybe<Float>;
  total_gt?: Maybe<Float>;
  total_gte?: Maybe<Float>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  savingsTarget?: Maybe<Float>;
  savingsTarget_not?: Maybe<Float>;
  savingsTarget_in?: Maybe<Float[] | Float>;
  savingsTarget_not_in?: Maybe<Float[] | Float>;
  savingsTarget_lt?: Maybe<Float>;
  savingsTarget_lte?: Maybe<Float>;
  savingsTarget_gt?: Maybe<Float>;
  savingsTarget_gte?: Maybe<Float>;
  AND?: Maybe<BudgetScalarWhereInput[] | BudgetScalarWhereInput>;
  OR?: Maybe<BudgetScalarWhereInput[] | BudgetScalarWhereInput>;
  NOT?: Maybe<BudgetScalarWhereInput[] | BudgetScalarWhereInput>;
}

export interface BudgetUpdateManyWithWhereNestedInput {
  where: BudgetScalarWhereInput;
  data: BudgetUpdateManyDataInput;
}

export interface BudgetUpdateManyDataInput {
  total?: Maybe<Float>;
  startDate?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  savingsTarget?: Maybe<Float>;
}

export interface UserUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface BudgetSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BudgetWhereInput>;
  AND?: Maybe<BudgetSubscriptionWhereInput[] | BudgetSubscriptionWhereInput>;
  OR?: Maybe<BudgetSubscriptionWhereInput[] | BudgetSubscriptionWhereInput>;
  NOT?: Maybe<BudgetSubscriptionWhereInput[] | BudgetSubscriptionWhereInput>;
}

export interface ExpenseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ExpenseWhereInput>;
  AND?: Maybe<ExpenseSubscriptionWhereInput[] | ExpenseSubscriptionWhereInput>;
  OR?: Maybe<ExpenseSubscriptionWhereInput[] | ExpenseSubscriptionWhereInput>;
  NOT?: Maybe<ExpenseSubscriptionWhereInput[] | ExpenseSubscriptionWhereInput>;
}

export interface SavingsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SavingsWhereInput>;
  AND?: Maybe<SavingsSubscriptionWhereInput[] | SavingsSubscriptionWhereInput>;
  OR?: Maybe<SavingsSubscriptionWhereInput[] | SavingsSubscriptionWhereInput>;
  NOT?: Maybe<SavingsSubscriptionWhereInput[] | SavingsSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Budget {
  id: ID_Output;
  total: Float;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
  savingsTarget: Float;
}

export interface BudgetPromise extends Promise<Budget>, Fragmentable {
  id: () => Promise<ID_Output>;
  total: () => Promise<Float>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  savingsTarget: () => Promise<Float>;
  expenses: <T = FragmentableArray<Expense>>(args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savings: <T = FragmentableArray<Savings>>(args?: {
    where?: SavingsWhereInput;
    orderBy?: SavingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BudgetSubscription
  extends Promise<AsyncIterator<Budget>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  total: () => Promise<AsyncIterator<Float>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  savingsTarget: () => Promise<AsyncIterator<Float>>;
  expenses: <T = Promise<AsyncIterator<ExpenseSubscription>>>(args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savings: <T = Promise<AsyncIterator<SavingsSubscription>>>(args?: {
    where?: SavingsWhereInput;
    orderBy?: SavingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BudgetNullablePromise
  extends Promise<Budget | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total: () => Promise<Float>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  savingsTarget: () => Promise<Float>;
  expenses: <T = FragmentableArray<Expense>>(args?: {
    where?: ExpenseWhereInput;
    orderBy?: ExpenseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  savings: <T = FragmentableArray<Savings>>(args?: {
    where?: SavingsWhereInput;
    orderBy?: SavingsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Expense {
  id: ID_Output;
  expenseAmount: Float;
  expenseDesc: String;
  expenseCategory: String;
}

export interface ExpensePromise extends Promise<Expense>, Fragmentable {
  id: () => Promise<ID_Output>;
  expenseAmount: () => Promise<Float>;
  expenseDesc: () => Promise<String>;
  expenseCategory: () => Promise<String>;
}

export interface ExpenseSubscription
  extends Promise<AsyncIterator<Expense>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  expenseAmount: () => Promise<AsyncIterator<Float>>;
  expenseDesc: () => Promise<AsyncIterator<String>>;
  expenseCategory: () => Promise<AsyncIterator<String>>;
}

export interface ExpenseNullablePromise
  extends Promise<Expense | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  expenseAmount: () => Promise<Float>;
  expenseDesc: () => Promise<String>;
  expenseCategory: () => Promise<String>;
}

export interface Savings {
  id: ID_Output;
  total: Float;
  month: String;
  monthAmount: Float;
}

export interface SavingsPromise extends Promise<Savings>, Fragmentable {
  id: () => Promise<ID_Output>;
  total: () => Promise<Float>;
  month: () => Promise<String>;
  monthAmount: () => Promise<Float>;
}

export interface SavingsSubscription
  extends Promise<AsyncIterator<Savings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  total: () => Promise<AsyncIterator<Float>>;
  month: () => Promise<AsyncIterator<String>>;
  monthAmount: () => Promise<AsyncIterator<Float>>;
}

export interface SavingsNullablePromise
  extends Promise<Savings | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total: () => Promise<Float>;
  month: () => Promise<String>;
  monthAmount: () => Promise<Float>;
}

export interface BudgetConnection {
  pageInfo: PageInfo;
  edges: BudgetEdge[];
}

export interface BudgetConnectionPromise
  extends Promise<BudgetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BudgetEdge>>() => T;
  aggregate: <T = AggregateBudgetPromise>() => T;
}

export interface BudgetConnectionSubscription
  extends Promise<AsyncIterator<BudgetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BudgetEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBudgetSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BudgetEdge {
  node: Budget;
  cursor: String;
}

export interface BudgetEdgePromise extends Promise<BudgetEdge>, Fragmentable {
  node: <T = BudgetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BudgetEdgeSubscription
  extends Promise<AsyncIterator<BudgetEdge>>,
    Fragmentable {
  node: <T = BudgetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBudget {
  count: Int;
}

export interface AggregateBudgetPromise
  extends Promise<AggregateBudget>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBudgetSubscription
  extends Promise<AsyncIterator<AggregateBudget>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExpenseConnection {
  pageInfo: PageInfo;
  edges: ExpenseEdge[];
}

export interface ExpenseConnectionPromise
  extends Promise<ExpenseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExpenseEdge>>() => T;
  aggregate: <T = AggregateExpensePromise>() => T;
}

export interface ExpenseConnectionSubscription
  extends Promise<AsyncIterator<ExpenseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExpenseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExpenseSubscription>() => T;
}

export interface ExpenseEdge {
  node: Expense;
  cursor: String;
}

export interface ExpenseEdgePromise extends Promise<ExpenseEdge>, Fragmentable {
  node: <T = ExpensePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExpenseEdgeSubscription
  extends Promise<AsyncIterator<ExpenseEdge>>,
    Fragmentable {
  node: <T = ExpenseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateExpense {
  count: Int;
}

export interface AggregateExpensePromise
  extends Promise<AggregateExpense>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExpenseSubscription
  extends Promise<AsyncIterator<AggregateExpense>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SavingsConnection {
  pageInfo: PageInfo;
  edges: SavingsEdge[];
}

export interface SavingsConnectionPromise
  extends Promise<SavingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SavingsEdge>>() => T;
  aggregate: <T = AggregateSavingsPromise>() => T;
}

export interface SavingsConnectionSubscription
  extends Promise<AsyncIterator<SavingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SavingsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSavingsSubscription>() => T;
}

export interface SavingsEdge {
  node: Savings;
  cursor: String;
}

export interface SavingsEdgePromise extends Promise<SavingsEdge>, Fragmentable {
  node: <T = SavingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SavingsEdgeSubscription
  extends Promise<AsyncIterator<SavingsEdge>>,
    Fragmentable {
  node: <T = SavingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSavings {
  count: Int;
}

export interface AggregateSavingsPromise
  extends Promise<AggregateSavings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSavingsSubscription
  extends Promise<AsyncIterator<AggregateSavings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  firstName: String;
  lastName: String;
  email: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  budgets: <T = FragmentableArray<Budget>>(args?: {
    where?: BudgetWhereInput;
    orderBy?: BudgetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  budgets: <T = Promise<AsyncIterator<BudgetSubscription>>>(args?: {
    where?: BudgetWhereInput;
    orderBy?: BudgetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  budgets: <T = FragmentableArray<Budget>>(args?: {
    where?: BudgetWhereInput;
    orderBy?: BudgetOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BudgetSubscriptionPayload {
  mutation: MutationType;
  node: Budget;
  updatedFields: String[];
  previousValues: BudgetPreviousValues;
}

export interface BudgetSubscriptionPayloadPromise
  extends Promise<BudgetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BudgetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BudgetPreviousValuesPromise>() => T;
}

export interface BudgetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BudgetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BudgetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BudgetPreviousValuesSubscription>() => T;
}

export interface BudgetPreviousValues {
  id: ID_Output;
  total: Float;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
  savingsTarget: Float;
}

export interface BudgetPreviousValuesPromise
  extends Promise<BudgetPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total: () => Promise<Float>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  savingsTarget: () => Promise<Float>;
}

export interface BudgetPreviousValuesSubscription
  extends Promise<AsyncIterator<BudgetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  total: () => Promise<AsyncIterator<Float>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  savingsTarget: () => Promise<AsyncIterator<Float>>;
}

export interface ExpenseSubscriptionPayload {
  mutation: MutationType;
  node: Expense;
  updatedFields: String[];
  previousValues: ExpensePreviousValues;
}

export interface ExpenseSubscriptionPayloadPromise
  extends Promise<ExpenseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExpensePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExpensePreviousValuesPromise>() => T;
}

export interface ExpenseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExpenseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExpenseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExpensePreviousValuesSubscription>() => T;
}

export interface ExpensePreviousValues {
  id: ID_Output;
  expenseAmount: Float;
  expenseDesc: String;
  expenseCategory: String;
}

export interface ExpensePreviousValuesPromise
  extends Promise<ExpensePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  expenseAmount: () => Promise<Float>;
  expenseDesc: () => Promise<String>;
  expenseCategory: () => Promise<String>;
}

export interface ExpensePreviousValuesSubscription
  extends Promise<AsyncIterator<ExpensePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  expenseAmount: () => Promise<AsyncIterator<Float>>;
  expenseDesc: () => Promise<AsyncIterator<String>>;
  expenseCategory: () => Promise<AsyncIterator<String>>;
}

export interface SavingsSubscriptionPayload {
  mutation: MutationType;
  node: Savings;
  updatedFields: String[];
  previousValues: SavingsPreviousValues;
}

export interface SavingsSubscriptionPayloadPromise
  extends Promise<SavingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SavingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SavingsPreviousValuesPromise>() => T;
}

export interface SavingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SavingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SavingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SavingsPreviousValuesSubscription>() => T;
}

export interface SavingsPreviousValues {
  id: ID_Output;
  total: Float;
  month: String;
  monthAmount: Float;
}

export interface SavingsPreviousValuesPromise
  extends Promise<SavingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total: () => Promise<Float>;
  month: () => Promise<String>;
  monthAmount: () => Promise<Float>;
}

export interface SavingsPreviousValuesSubscription
  extends Promise<AsyncIterator<SavingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  total: () => Promise<AsyncIterator<Float>>;
  month: () => Promise<AsyncIterator<String>>;
  monthAmount: () => Promise<AsyncIterator<Float>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  firstName: String;
  lastName: String;
  email: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Budget",
    embedded: false
  },
  {
    name: "Expense",
    embedded: false
  },
  {
    name: "Savings",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
